from functools import reduce
from operator import add

from filtration import Filtration
from clique import Chain

class HomologyClass():
    def __init__(self, dimension, generator, birth = 0):
        self.dimension = dimension
        self.birth = birth
        self.death = -1
        self.generator = generator

    @staticmethod
    def empty(d):
        return HomologyClass(d, [])

    def kill(self, k):
        self.death = k 

    @property
    def is_zero(self):
        return not self.generator.cliques

    def __add__(self, other):
        if self.dimension != other.dimension:
            raise ValueError("Homology classes must be of the same dimension to be added")
        return HomologyClass(self.dimension, self.generator +
                other.generator)

    def __repr__(self):
        return "H[" + repr(self.generator) + "]"

    def __str__(self):
        return (f"{self.dimension}-dimensional homology class generated by the chain: " 
            + repr(self.generator))
    
    
def compute_persistent_homology(filtration):
    classes = dict(zip(filtration.complex, [None]*len(filtration.complex)))
    homology_generators = [[] for _ in range(filtration.cloud.dim + 1)]
    
    for k in range(filtration.cloud.dim + 2): # need to figure out the limits
        for c in filtration[k]:
            print(f"\n-----\nProcessing {c}")
            # Give the clique a homology class (it is not homologous to anything other
            # than itself since it is not the face of anything as of now
            classes[c] = HomologyClass(c.dim, Chain([c]), k)

            if c.dim == 0 or reduce(add, [classes[f] for f in c.faces]).is_zero:
                # This clique closes a cycle
                print(repr(c) + " closes a cycle")
                homology_generators[c.dim].append(classes[c])
                
            else:
                # The youngest face is declared homologous to the sum of the other faces
                youngest, *faces_other = sorted(c.faces, key = lambda c:(c.k, c.size,
                    c.diameter))
                classes[youngest].kill(k)
                classes[youngest] = reduce(add, [classes[f] for f in faces_other])

            print(classes)

    return homology_generators

