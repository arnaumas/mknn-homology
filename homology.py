from functools import reduce
from operator import add

from filtration import Filtration
from clique import Chain
from homology_dict import HomDict

class HomologyClass():
    def __init__(self, dimension, generator, representatives, birth = 0):
        self.dimension = dimension
        self.birth = birth
        self.death = -1
        self.generator = generator
        self.representatives = set(representatives)
        self.lifetime = []

    @property
    def is_dead(self):
        if self.death == -1:
            return False
        else:
            return True

    @property
    def is_zero(self):
        return not self.generator.cliques

    @property
    def size(self):
        return len(self.representatives)

    @staticmethod
    def empty(d):
        return HomologyClass(d, [], [])

    def kill(self, k):
        self.death = k 

    def __add__(self, other):
        if self.dimension != other.dimension:
            raise ValueError("Homology classes must be of the same dimension to be added")
        return HomologyClass(self.dimension, self.generator +
                other.generator, self.representatives | other.representatives)

    def __repr__(self):
        return "H[" + repr(self.generator) + "]"

    def __str__(self):
        return (f"{self.dimension}-dimensional homology class generated by the chain: " 
            + repr(self.generator))
    
def process(k, filtration, homology, generators):
    for c in filtration[k]:
        # Give the clique a homology class (it is not homologous to anything other
        # than itself since it is not the face of anything as of now)
        homology[c] = HomologyClass(c.dim, Chain([c]), c.points, k)

        faces = c.faces(filtration.complex)

        if c.dim == 0 or reduce(add, [homology[f] for f in faces]).is_zero:
            # This clique closes a cycle
            generators[c.dim].append(homology[c])
            print(repr(c) + ' closes a cycle')
            
        else:
            # Processing is different for the case of dimension 0
            if c.dim == 1:
                small, large = sorted(faces,
                        key = lambda c:len(homology[c].representatives))
                homology[large].representatives |= homology[small].representatives
                homology[small] = homology[large]
            
            else:
                # The youngest face is declared homologous to the sum of the other faces
                youngest, *faces_other = sorted(faces, key = lambda c:(c.k, c.size,
                    c.diameter), reverse = True)
                # Store the persistence data of the class to be killed
                # if homology[youngest].dimension == 0:
                #     persistence += [(
                    
                homology[youngest].kill(k)
                homology[youngest] = reduce(add, [homology[f] for f in faces_other])
    
def compute_persistent_homology(filtration):
    homology = HomDict(zip(filtration.complex, classes))
    homology_generators = [[]]*filtration.cloud.dim
    persistence = []
    
    for k in range(filtration.k_max + 1): 
        for c in filtration[k]:
            # Give the clique a homology class (it is not homologous to anything other
            # than itself since it is not the face of anything as of now)
            homology[c] = HomologyClass(c.dim, Chain([c]), c.points, k)

            if c.dim == 0 or reduce(add, [homology[f] for f in c.faces]).is_zero:
                # This clique closes a cycle
                homology_generators[c.dim].append(homology[c])
                
            else:
                # Processing is different for the case of dimension 0
                if c.dim == 1:
                    small, large = sorted(c.faces,
                            key = lambda c:len(homology[c].representatives))
                    homology[large].representatives |= homology[small].representatives
                    homology[small] = homology[large]
                
                else:
                    # The youngest face is declared homologous to the sum of the other faces
                    youngest, *faces_other = sorted(c.faces, key = lambda c:(c.k, c.size,
                        c.diameter))
                    # Store the persistence data of the class to be killed
                    # if homology[youngest].dimension == 0:
                    #     persistence += [(
                        
                    homology[youngest].kill(k)
                    homology[youngest] = reduce(add, [homology[f] for f in faces_other])

        # Update the homology 
        for hom_class in homology.values():
            if not(hom_class is None or hom_class.is_dead):
                hom_class.lifetime += [
                        (k/filtration.k_max, 
                            len([clique for clique in filtration.complex
                                if homology[clique] == hom_class])/filtration.cloud.size)
                            ]

    return classes, homology, homology_generators

